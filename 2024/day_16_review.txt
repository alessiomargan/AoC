Day 16 Solution Review
======================

Overview
--------
You're solving the Reindeer Maze problem using A* search with orientation-aware
state space. The maze is a grid where a reindeer moves with direction (^, v, <, >)
and turning costs more than moving forward.

Strengths ‚úÖ
-----------

1. Clean state representation
   - `Loc` namedtuple with `(row, col, orient)` nicely captures position + direction.

2. Proper A* implementation
   - Your `a_star_search` correctly implements priority queue, cost tracking, and heuristic.

3. Smart cost function
   - Turning costs 1001 vs forward movement costs 1 ‚Äî matches the AoC Day 16 spec.

4. Good neighbor generation
   - Each orientation produces 3 moves: forward + 2 turns.

5. Visualization helpers
   - `draw_grid` and `draw_tile` are great for debugging.


Issues & Bugs üêõ
----------------

CRITICAL: Part 2 logic is incorrect
------------------------------------

Your Part 2 implementation has several problems:

1. Generator usage is wrong
   - You call `next(search_gen(...))` once and stop at the first time the goal
     is reached, but you need to explore ALL optimal paths with the same cost.

2. `came_from` tracking is incomplete
   - You append to `came_from[next]` but never handle the case where multiple
     paths reach the same node with equal cost. Current code:

     if next not in cost_so_far or new_cost < cost_so_far[next]:
         # ...
         came_from[next].append(current)

   This only appends when cost is **strictly better**, not when cost is **equal**.
   You need:

     if next not in cost_so_far or new_cost <= cost_so_far[next]:
         if next not in cost_so_far or new_cost < cost_so_far[next]:
             cost_so_far[next] = new_cost
             came_from[next] = []  # reset parent list
         came_from[next].append(current)

3. Wrong answer for Part 2
   - `res_b = len(path)` only counts tiles in a single path. Part 2 asks:
     **how many tiles are on ANY optimal path?** You need to:
     * Find all paths with minimum cost
     * Collect unique positions from all those paths
     * Count unique `(row, col)` positions

4. `reconstruct_path` doesn't handle multiple parents
   - It assumes each node has a single parent. For Part 2, you need BFS/DFS
     through `came_from` to collect all paths.


Minor issues
------------

5. Heuristic may be inadmissible
   - Manhattan distance ignores turning cost. If the optimal path requires turns,
     manhattan underestimates cost and A* may not find the true optimum. For Part 1,
     using Dijkstra (heuristic=0) is safer.

6. Unused `__eq__` override in `Loc`
   - Your `__eq__` compares only position, ignoring orientation. This breaks
     dictionary/set lookups because `Loc(1,2,'^')` and `Loc(1,2,'>')` would be
     equal but have different hashes. Either:
     * Remove the override (use default namedtuple equality)
     * Or override `__hash__` to match (but that's complex)

7. Hardcoded test data
   - `maze_str` and `maze_str_` are test inputs. Good for dev, but consider
     moving to separate test files.


Suggested Fixes
---------------

Fix Part 2 (all optimal paths)
-------------------------------

Replace your `search_gen` approach with a modified Dijkstra that tracks all parents:

```python
def dijkstra_all_paths(graph: ReindeerMazeGrid, start: Loc, goal: Loc):
    """Find all paths with minimum cost."""
    frontier = PriorityQueue()
    frontier.put(start, 0)
    came_from = defaultdict(list)  # each node can have multiple parents
    cost_so_far = {}
    cost_so_far[start] = 0

    goal_cost = float('inf')
    goals_reached = []

    while not frontier.empty():
        current = frontier.get()
        current_cost = cost_so_far[current]

        # Skip if we've already found cheaper path to goal
        if current_cost > goal_cost:
            continue

        # Check if we reached goal
        if current.pos() == goal.pos():
            if current_cost < goal_cost:
                goal_cost = current_cost
                goals_reached = [current]
            elif current_cost == goal_cost:
                goals_reached.append(current)
            continue

        for next in graph.neighbors(current):
            new_cost = current_cost + graph.cost(current, next)

            if next not in cost_so_far:
                # First time reaching this node
                cost_so_far[next] = new_cost
                frontier.put(next, new_cost)
                came_from[next] = [current]
            elif new_cost == cost_so_far[next]:
                # Equal cost path - add parent
                came_from[next].append(current)
            elif new_cost < cost_so_far[next]:
                # Better path found - reset
                cost_so_far[next] = new_cost
                frontier.put(next, new_cost)
                came_from[next] = [current]

    return goals_reached, came_from, cost_so_far

def collect_all_tiles(came_from, goals):
    """Collect all unique (row,col) positions on any optimal path."""
    tiles = set()
    visited = set()
    stack = list(goals)

    while stack:
        current = stack.pop()
        if current in visited:
            continue
        visited.add(current)
        tiles.add(current.pos())

        parents = came_from.get(current, [])
        if parents:  # None means start node
            stack.extend(parents)

    return tiles

# Usage:
goals, came_from, cost_so_far = dijkstra_all_paths(maze, start, goal)
all_tiles = collect_all_tiles(came_from, goals)
res_b = len(all_tiles)
```


Fix `Loc.__eq__` (remove it)
-----------------------------

```python
class Loc(namedtuple('Loc',['row','col','orient'])):
    __hash__ = tuple.__hash__
    # Remove __eq__ override - use default namedtuple equality
    def pos(self)-> GridLocation:
        return (self.row, self.col)
```


Testing Recommendations
-----------------------

1. Verify with sample input
   - AoC Day 16 provides test cases. Expected results for the first sample:
     * Part 1: 7036
     * Part 2: 45

2. Edge cases to test:
   - Maze with no solution
   - Single-tile start==goal
   - Multiple equally-optimal paths

3. Add assertions:
   ```python
   assert res_a == 7036, f"Part 1 sample failed: got {res_a}"
   assert res_b == 45, f"Part 2 sample failed: got {res_b}"
   ```


Performance Notes
-----------------

- Your current implementation is efficient for Part 1
- Part 2 fix adds minimal overhead (track multiple parents, BFS to collect tiles)
- Grid size is 141√ó141 = ~20K cells, A* should handle this quickly


Summary
-------

Part 1: Looks correct (assuming the heuristic doesn't cause issues ‚Äî test with
        sample input to confirm).

Part 2: Implementation is broken. You need to:
        1. Track all parents when costs are equal
        2. Collect ALL tiles on any optimal-cost path
        3. Count unique positions


Next Steps
----------

Options:
- Add the fixed Part 2 code to your notebook
- Add test cells with the sample inputs and expected outputs
- Create a standalone `day_16_solution.py` with the corrected logic
